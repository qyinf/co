# 简介

哈哈哈哈，终于找到了一些当时的文档，不过写的还是很简陋。

p6是在p5的基础上增加了乘法和除法指令。这两个指令都是需要进行多个周期的运算，因此设计也会更加复杂，需要有单独的乘除法部件。

# 提问

1. 为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？

   > 为了不影响乘除法指令以外的其他指令的流水。
   >
   > 在读取指令的时候会更加方便

 

2. 真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。

   > 计算机做乘法的方法和人类做乘法的方法是很相似的，把一个数和另一个数按位拆开进行相乘，相乘以后，然后进行一位，并且相加，最后就组成最后的结果。

 

3. 请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？

   > 在进行乘除法运算的时候，我会把busy置为1，乘除法结束以后，busy重新变为0
   >
   > 当busy为1的时候，通过对stall的设置，让stall也为1

 

4. 请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）

   > 可以很清楚地看出要写入的字节
   >
   > 并且便于添加指令，便于修改要写入的字节

 

5. 请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？

   > 不是同一字节
   >
   > 当存储方式是以字节为单位的时候

 

 

6. 为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？

   > 抽象：对于每一条指令，都把它抽象成tnew和tuse
   >
   > 帮助：这样做会让我在处理冲突的时候，只需要考虑每个指令的tnew和tuse就行，而不需要思考太多它的其他逻辑

 

7. 在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？

   > 比p5遇见的新暂停主要有以下几种：
   >
   > mult,mult
   >
   > Mfli,mult
   >
   > 解决方法就是ALU在计算乘除法的时候，busy设置为1，busy是1的时候，指令暂停执行
   >
   > 对于新冲突，可以把除了计算指令以外的其他乘除指令抽象为简单的r指令

 

8. 如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证覆盖了所有需要测试的情况；如果你是完全随机生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了特殊的策略，比如构造连续数据冒险序列，请你描述一下你使用的策略如何结合了随机性达到强测的效果。

   > 我是手动构造的样例
   >
   > 构造策略就是把P5新增的所有的冲突和暂停全部测试一遍

 

# 设计文档

## 流水的指令

Instr：通过define，可以在每一级迅速读取自己想要的信息

Pc：流水每一级的pc，这样可以在display阶段更加方便，并且便于jal类指令的写入

RegWrite，RegData，RegAddr：从D级开始流水与写寄存器相关的指令，主要的目的有两个

1. 在判断暂停的时候，有时候RegData虽然还没有被计算出来，但是却应该暂停，所以这个时候只需要根据指令信息读取RegWrite和RegAddr的值就可以了

2. 有的跳转指令，在D级就已经计算出RegData了，这个时候需要记录信息并流水下去

## 我设计的模块

基本上每个阶段有一个模块：

F级别：pc模块，主要负责pc的改变和取指令

D阶段：npc模块，传入pcF和pcD计算出npc的值

E阶段：在ALU的基础上补充了mf模块

M阶段：解码出相关的信息并输出

W阶段：输出写回的信息

 